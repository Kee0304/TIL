# 자바의 OOP
- 객체 변수: 클래스 내에 선언된 변수=속성
  - 객체명.객체변수로 접근 가능
  - 객체변수는 

## 메서드
- parameter(매개변수): 메서드에 전달된 값을 저장하는 변수
- arguments(인수): 메서드에 실제 전달하는 값

### 일반적인 메서드
- 입력 값이 있고 리턴 값이 있는 메서드
```java
int sum(int a, int b) {
    return a+b;
}
```

### 입력값이 없는 메서드
```java
String say() {
    return "Hi";
}
```

### 리턴 값이 없는 메서드
```java
void sum(int a, int b) {
    System.out.printLn(a+"과"+b+"의 합은 "+(a+b)+"입니다.");
}
```
- void 메서드는 리턴값이 없다.

### 입력 값도 리턴값도 없는 메서드
```java
void say() {
    Sytstem.out.printLn("Hi");
}
```

## 메서드 내의 변수
- 메서드 내에서 정의된 변수는 메서드 밖의 같은 이름을 갖고 있는 변수와는 상관 없이 동작한다.
- 즉 여러 메서드 내에서 활용해야할 변수라면 메서드 내부가 아닌 객체 변수로 선언해야한다.
  - 보통은 클래스명.객체변수명으로 부르지만 같은 클래스 내부라면 this.객체변수명으로도 불러올 수 있다.

## 값을 전달하는 것과 객체를 전달하는 것의 차이
- 메서드에 객체를 전달하면 메서드에서 객체의 객체 변수의 값을 변경할 수 있다.

## 상속
- 상위 클래스를 상속받는 하위 클래스를 만들어, 상위 클래스의 속성 및 메서드를 사용하거나 오버라이드할 수 있다.
```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Cat extends Animal {
    ...
}
```
- 위 처럼 extends를 사용하여 상속받을 부모(상위) 클래스를 지정한다.
- 자식 클래스의 객체는 부모 클래스의 자료형인 것처럼 사용할 수 있다.
```java
Animal dog = new Cat();
```
- OOP의 특성상, 모든 클래스는 Object 클래스를 상속받는다.
### 오버라이딩과 오버로딩
- 오버라이딩: 부모 클래스의 메서드를 자식 클래스가 동일한 형태로 재구현하여 사용
- 오버로딩: 부모 클래스의 메서드와 자식 클래스의 메서드가 이름은 같은데 입력 항목을 다르게 만들어서 사용. 이 경우 입력 형태가 부모 클래스의 메서드와 같으면 부모 클래스의 것을 그대로 사용하고, 입력값의 형태가 다르면 다른 동작을 한다.

### 다중상속
- 자바는 다중상속을 지원하지 않는다.

## 생성자
- 메서드명이 클래스명과 동일하고 리턴 자료형을 정의하지 않는(void도 사용하지 않는) 메서드를 생성자라고 한다.
```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Cat extends Animal {
    ...
}

class HomeCat extends Cat {
    HomeCat(String name) {
        this.setName(name);
    }
}
```
- 객체 생성 시 생성자의 규칙에 따라야만 객체를 생성할 수 있다. 아니면 오류남

### 디폴트 생성자
```java
class Cat extends Animal {
    Cat() {
    }
}
```
- 생성자의 입력 항목이 없고 생성자 내부에 아무 내용이 없는 생성자를 디폴트 생성자라고 부른다.
- 만약 클래스에 생성자가 하나도 없다면 컴파일러는 자동으로 위와 같은 디폴트 생성자를 추가한다.