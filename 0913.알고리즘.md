# 트리

## 1. 트리의 개념
- 비선형 구조, 그래프의 일종
- 사이클이 존재하지 않는다. 출발한 자리로 돌아올 수 없다,
- 모든 노드가 연결이 되어있다. 루트 노드가 1개이다.

- 원소들 간에 1:N 관계를 가지는 자료구조
- 원소들 간에 계층관계를 가지는 계층형 자료구조
- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조
- 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
  - 최상위 노드를 루트라고 한다.
  - 나머지 노드들은 n 의 분리 집합 T1,...,TN(subtree) 으로 분리될 수 있다.


## 2. 용어
1. 노드: 트리의 원소
2. edge(간선): 노드를 연결하는 선
3. 루트 노드: 트리의 시작 노드
4. 형제 노드: 같은 부모 노드를 같는 자식 노드들
5. 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
6. 서브 트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
7. 자손 노드: 서브 트리에 있는 하위 레벨 노드들
8. 차수
    - 노드의 차수: 노드에 연결된 자식 노드의 수
    - 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
    - 리프 노드(단말 노드): 차수가 0인 노드. 자식이 없는 노드
9. 높이 
    - 노드의 높이: 루트에서 노드에 이르는 간선의 수
    - 트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값
    - 깊이: 자신을 제외한 조상 노드의 개수

## 3. 이진 트리
- 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리
- 루트의 높이를 0이라 했을 때, 레벨 i에서 노드 최대의 개수는 2<sup>i</sup>개
### 1) 포화 이진 트리
- 모든 레벨에 노드가 포화상태로 차 있는 이진 트리. 높이가 h일 때 최대의 노드 개수인 (2<sup>h+1</sup>-1)개의 노드를 가진 이진 트리
- 루트를 1번으로 하여 2<sup>h+1</sup>-1까지 정해진 위치에 대한 노드 번호를 가짐

### 2) 완전 이진 트리
- 높이가 h고 노드가 n개일 때, 노드 1번부터 n번까지 빈 자리가 없는 이진 트리
```
            1
        ↙     ↘
    2              3
  ↙  ↘          ↙
4       5       6
```

### 3) 편향 이진 트리
- 한쪽 방향으로만 자식을 가지는 트리
```
         1
      ↙
    2
  ↙ 
3 
```

## 4. 순회
- 트리의 노드들을 체계적으로 방문하는 것

### 이진 트리의 3가지 기본적인 순회방법
- V부모 L왼쪽 R오른쪽
1. 전위 순회(preorder traversal VLR): 부모노드 방문 후, 서브 트리들을 좌, 우 순서로 방문한다. 
2. 중위 순회(inorder traversal LVR): 왼쪽 서브 트리, 부모노드, 오른쪽 서브 트리 순으로 방문한다.
3. 후위 순회(postorder traversal LRV): 왼쪽 서브트리를 좌우 순서로 방문한 후, 부모노드로 방문한다.


## 5. 이진 트리의 표현
- 루트의 번호를 1로
- 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2<sup>n</sup>부터 2<sup>n+1</sup>-1 까지 번호를 차례대로 부여
### 1) 배열을 이용한 이진 트리의 표현
- 노드 번호의 성질
  - 노드 번호가 i인 노드의 부모 노드 번호는 ⌊i/2⌋(내림) 
  - 노드 번호가 i인 노드의 부모 노드 번호는 2<sup>i</sup>
  - 노드 번호가 i인 노드의 부모 노드 번호는 2<sup>i</sup>+1
  - 레벨 n의 노드 기작 번호는 2<sup>n</sup>

### 2) 완전 이진트리가 이닌 경우
```
4
1 2 1 3 3 4 3 5

            1
       ↙       ↘
    2               3
                 ↙    ↘
               4         5
```
- 부모 번호를 인덱스로 자식 번호를 저장
```
부모    p   0   1   2   3   4   5
자식1  ch1  0   2   0   4   0   0   
자식2  ch2  0   3   0   5   0   0
```
```
def find_root(V):
    for i in range(1, V+1):
        if par[i]==0:
            return i

def preoder(n):
    if n:
        print(n)
        preorder(ch1[n])
        preorder(ch2[n])

def inorder(n):
    if n:
        inorder(ch1[n])
        print(n)
        inorder(ch2[n])

def postorder(n):
    if n:
        postorder(ch1[n])
        postorder(ch2[n])
        print(n)


E=int(input())
arr=list(map(int,input().split()))
V=E+1
ch1=[0]*(V+1)
ch2=[0]*(V+1)
par=[0]*(V+1)
for i in range(E):
    p,c=arr[i*2],arr[(i*2)+1]
    if ch1[p]==0:
        ch1[p] = c
    else:
        ch2[p] = c
    par[c]=p

find_root(V)

preorder(root)
inorder(root)
postorder(root)
```

- 자식 번호를 인덱스로 부모 번호를 저장
```
자식    c   0   1   2   3   4   5
부모   par  0   0   1   1   3   3
```

### 3) 단점
- 편향 이진 트리 등에서는 메모리 낭비가 꽤 있다.
- 새로운 노드를 추가하는 등의 경우 배열의 길이와 인덱스를 다 바꿔줘야 되어서 불편함이 크다.

```
def pre(n):
    if n <=size:
        print(tree[n])
        pre(2*n)
        pre(2*n+1)

tree=[0,'A','B','C','D','E','F']
size=len(tree) -1
pre(2)
```

## 6. 수식 트리
- 수식을 표현하는 이진 트리
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 잎 노드
```
            +
        ↙     ↘
    *              - 
  ↙  ↘         ↙  ↘ 
4       5      6      4
```
- 중위 순회를 하면 중위 표기법, 후위 순회를 하면 후위표기법으로 표기된다.

## 7. 이진 탐색 트리
- 탐색 작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 primary key를 갖는다.
- key(왼쪽 서브트리)<key(루트 노드)<key(오른쪽 서브트리).
- 즉, 찾고자 하는 놈이 지금 노드보다 크면 오른쪽으로, 작으면 왼쪽으로 가면서 탐색하는 방법이다.
- 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다.
- 중위 순회하면 오름차순으로 정열된 값을 얻을 수 있다.

### 1) 삽입 연산
- 먼저 탐색 연산을 수행
- 탐색 실패한 위치에서 원소를 삽입한다.

### 2) 삭제 연산
- 탐색을 한다.
  - 자식이 없으면 그냥 지우면 된다.
  - 자식이 하나면, 그 지우고자 하는 놈의 자식을 그 지우고자 하는 놈의 부모를 참조하게 만들고 삭제한다.
  - 루트를 삭제하려고 할 때는, 왼쪽 서브트리를 중위순회를 해서 나온 가장 마지막 놈을 루트 노드로 바꾸고 그 자리는 삭제한 후, 원래 루트를 없앤다. 


## 8. 힙(heap)
- 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 노드를 찾기 위해서 만든 자료 구조
1. 최대 힙
- 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 부모노드의 키값>자식노드의 키값
- 루트 노드: 키값이 가장 큰 노드

2. 최소 힙
- 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
- 부모노드의 키값<자식노드의 키값
- 루트 노드: 키값이 가장 작은 노드


### 1) 힙 연산 - 삽입
- 완전 이진 트리에서 삽입할 자리를 확장한다.
- 추가할 놈과 해당 자리의 부모를 비교해서 부모가 크면, 그냥 삽입하면 된다.
- 아니라면 삽입할 자리에 그 자리의 부모를 넣고 추가할 놈이 부모 자리에 넣어진다. 그 후, 그 자리의 부모와 비교를 한다.
```
def enq(n):
    global last
    last+=1         # 마지막 정점 추가
    heap[last]=n    # 마지막 정점에 key 추가
    c=last
    p=c//2          # 부모 정점 번호
    while p and heap[p]<heap[c]:
        heap[p],heap[c]=heap[c],heap[p]
    

heap=[0]*100
last=0
```

### 2) 힙 연산 - 삭제
- 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
- 루트 노드의 원소를 삭제하여 반환한다.
- 힙 종류에 따라 최대값 또는 최소값을 구할 수 있다.
- 루트 노드의 원소를 삭제하면서 마지막 노드 놈을 루트 노드로 올리고 마지막 노드를 삭제
- 자식과 크기 비교 후 자리 바꾸기
```
def deq(n):
    global last
    tmp = heap[1]           # 루트 백업
    heap[1] = heap[last]    # 삭제할 노드의 키를 루트에 복사
    last -=1                # 마지막 노드 삭제
    p=1                     # 루트에 옮긴 값을 자식과 비교
    c=p*2                   # 왼쪽 자식
    while c<=last:          # 자식이 하나라도 있으면
        if c+1<=last and heap[c] < heap[c+1]: # 오른쪽 자식도 있고 오른쪽 자식이 더 크면
            c+=1            # 비교 대상을 오른쪽 자식으로 정함
        if heap[p]<heap[c]: # 자식이 더 크면 최대합 규칙에 어긋나므로
            heap[p],heap[c]=heap[c],heap[p]
            p=c             # 자식을 새로운 부모로
            c=p*2
        else:
            break

    return tmp
```

## 파이썬에서의 heap
```
import heapq

a=[5,8,9,2,6,1,19]
heapq.heapify(a)    # [1,2,5,8,6,9,19] 내부적으로 트리 형태로 저장되어있음
```
- 내부적으로 최소 힙으로 구현되어있다.
- 최대 힙으로 다루고 싶다면