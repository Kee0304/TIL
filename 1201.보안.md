# 3가지 자동화 테스팅 기법
- 소스 코드 점검 sast(software application security testing)
- 소스 코드 실행 상태에서의 웹 취약점 점검 dast(dynmic ~)
- 라이브러리, 오픈 소스 등의 취약점 점검 sca(software composition analysis)

# 점검 기준 관련 해외 기관
- OWASP 3년동아 dast를 취합해서 정리/갱신
  - TOP TEN
- WASC
- MITRE
  - CWE
    - 소프트웨어 보안 기준 49가지
  - CVE Common Vulnerabilities and Exposure

# 소프트웨어 보안약점 점검 기준 (≒ sast)
- 입력 데이터 검증: 사용자, 프로그램 입력 데이터에 대한 유효성 검증체계를 갖추고, 실패 시 처리할 수 있도록 설계
- 보안: 인증, 접근통제, 권한관리, 비밀번호 등의 정책이 적절하게 반여욀 수 있도록 설계
- 시간 및 상태: 자원을 사용하는 시점과 검사하는 시점이 달라서 자원의 상태변동으로 야기되는 보안 취약점
- 에러처리: 에러 또는 오류상황을 처리하지 않거나 불충분하게 처리되어 중요 정보 유출 등 보안 약점이 발생하지 않도록 설계
- 코드오류: 복잡한 소스, 가독성 저하, 코드오류가 발생되지 않도록 설계
- 캡슐화: 중요 데이터에 대한 비인가자 접근이 허용되지 않도록 설계
- API 도용: 비정상적인 API를 사용하지 않도록 설계

## 대표적인 종류
- Broken Access Control(접근 권한 취약점): 엑세스 제어가 취약해 사용자가 주어진 권한을 벗어나 모든 데이터를 무단으로 열람, 수정 혹은 삭제 등의 행위로 이어짐
- Cryptographic Failures(암호화 오류): 민감한 데이터의 적절한 암호화가 이루어지지 않음
- Injection: 신뢰할 수 없는 데이터가 명령어나 쿼리문 일부분으로써 인터프리터로 보내짐
- Insecure Design: 누락이나 비효율적인 설계로 발생하는 다양한 취약점.
- Security Misconfiguration(보안 설정 오류): 어플리케이션 스택의 적절한 보안 강화가 누락되었거나 클라우드 서비스에 대한 권한이 적절하지 않게 구성됐을 때, 불필요한 기능이 활성되거나 설치되었을 때, 기본계정 및 암호화가 변경되지 않았을 때, 지나치게 상세한 오류메세지를 노출할 때, 최신 보안기능이 비활성화 되거나 안전하지 않게 두성되었을 때
- Vunerable and Outdated Components(취약하고 오래된 요소)

## 소프트웨어 개발보안
- 요구사항 분석
  - 요구사항 중 보안 항복 식별
  - 요구사항 명세서
- 설계
  - 위협원 도출을 위한 위협모델링
  - 보안 설계 및 검토 및 보안설계서 작성
  - 보안 통제 수립
- 구형
  - 표준 코딩 정의서 및 SW개발보안 가이드를 준수해 개발
  - 소스코드 보안 약점 진단 및 개선
- 테스트
  - 모의 침투 테스트 또는 동전분석을 통한 보안취약점 진단 및 개선
- 유지보수
  - 지속적인 개선
  - 보안 패치




# 점검기준
## 보안 기능
### 인증관리
- 인증 대상 및 방식
- 인증 수행 제한
- 비밀번호 관리

### 접근 권한 관리
- 중요자원 접근 통제
### 암호 관리
- 암호키 관리: 암호키 생성, 분배, 접근, 파기 등 암호키 생명 주기별 암호키 관리 방법을 안전하게 설계
- 암호연산: 국제 표준 또는 검증필 암호모듈로 등재된 안전한 암호 알고리즘을 선정하소 충분한 암호키 길이, 솔트, 충분한 난수값을 적용한 안전한 암호연산 수행방법 설계

### 중요정보 처리
- 중요 정보 안전하게 저장
- 중요 정보 안전하게 전송

## 에러 처리
- 예외처리: 오류메세지에 중요정보가 노출되거나 부적절한 오류/에러 처리로 의도치 않은 상황이 발생하지 않도록 설계

## 세션 통제
- 다른 세션 간 데이터 공유 금지, 세션 ID 노출 금지, (재)로그인시 세션 ID 변경, 세션종료(비활성화,유효기간 등) 처리 등 세션을 안전하게 관리할수 있는 방안 설계

# SQL Injection
- 에러기반: 에러 정보를 이용하여 데이터베이스 및 쿼리 구조 등의 정보를 추측해 공격에 활용. 즉 Null을 막 집어넣어 쿼리 개수를 통해 필드의 개수를 알아내거나 숫자, 문자, SQL문 등을 집어넣어 쿼리에 따른 DB의 반응을 찾아냄.
- Union 기반: UNION은 2개 이상의 쿼리를 요청하여 결과를 얻는 SQL 연산자이며 공격자는 이를 악용하여 쵸엉에 한 개의 추가 쿼리를 삽입하여 정보를 얻어내는 방식. 에러가 발생하는 사이트에서 사용 가능
- xp cmdshell 기반: 저장 프로시저는 운영상 편이를 위해 만들어둔 SQL 집합형태이며, xp_cmdshell은 윈도우 명령어를 실행하도록 역할을 제공하기 때문에 자주 악용. 즉 웹 상에서 윈도우 명령어를 사용해서 공격

&nbsp;

- Blind 기반: 에러가 발생되지 않는 사이트에서 정상적인 쿼리가 수행되는지 아닌 지에 따라 취약점을 찾아냄
- Blind-Time 기반: 쿼리 결과를 특정시간만큼 지연시키는 방법을 이용해, 해당 지연 쿼리가 작동하면 취약점의 있다고 판단하여 취약점을 찾아내려고 함

## 방지
- 어플리케이션에서 DB연결을 통해 데이터를 처리하는 경우 최소 권한이 설정된 계정을 사용해야 한다.
- 외부 입력값이 삽입되는 SQL 쿼리문을 동적으로 생성해서 실행하지 않도록 한다.
- 외부 입렵값을 이용해 동적으로 SQL 쿼리문을 생성해야 하는 경우, 입력값에 대한 검증을 수행한 뒤 사용해야 한다.

# XML 조회 및 결과 검증 Xpath
- XML 조회 시 질의문 내 입력값과 조회결과에 대한 유효성 검증 방법 설계 및 유효하지 않은 값에 대한 처리방법을 설계해야 한다
- 에러 기반과 비슷하게 폼에 계속해서 구문을 넣어봄
- 보통 입력문이 들어올 때 먼저 필터링을 하도록 작성하여 방지

## XML entities
- XXE: XML 데이터를 직접 입력받고 출력해주는 페이지의 경우 발생 가능성
- external extities를 disable 한다.


# 시스템 자원 접근 및 명령어 수행 입력값 검증
- url을 통해 파일에 접근하려는 시도
- form에 명령어를 삽입해서 원하는 명령을 실행


# 역직렬화
- 공격자는 직렬화된 데이터에 악의적인 코드를 삽입하고 이를 검증없이 역직렬화 하는 경우 원격지 명령 시랭 등의 취약점이 발생됨
- 중요한 데이터에 대해선 직렬화를 하지 않거나, JSON을 사용하면 비교적 안전

# XSS 크로스 사이트 스크립팅
- 악의적인 스크립트 삽입 및 실행을 통해서 쿠키에 있는 사용자의 정보를 가로채기에 사용됨 

## Stored XSS
- DB에 저장할 내용에 스크립트를 삽입해서 해당 객체가 DB에서 꺼내어질 때 스크립트가 실행

## DOM XSS
- 공격 스크립트가 DOM 생성의 일부로 실행되면서 공격을 수행

# CSRF
- 피해자가 서비스에 로그인한 상태에서 해커가 만든 피싱 사이트에 접속하여 의도치않게 공격을 수행하는 행위
- CSRF 토큰을 사용해도 XSS 취약점이 있는 사이트를 통해 공격하게 되면 무력화 될 수 있으므로 CAPTCHA와 같은 사용자와 상호 처리 가능한 기법을 적용하여 위조된 요청이 차단될 수 있도록 설계한다.

# CRLF HTTP Response spliting
- 응답에 스크립트 형태를 넣어 HTML에 부착시키면서 실행됨
- 보안을 위해 헤더값을 추가하면 실행되지 않는다.

# 신뢰하지 않는 URL 자동 접속
- 외부로부터 입력받은 URL에 검증 없이 이동해버리는 문제
- 화이트리스트 URL 리스트 작성

# 보안 기능 입력값 검증
- 사용자의 역할, 권한을 결정하는 정보는 서버에서 관리
- 쿠키값, 환경변수, 파라미터 등 외부입력값이 보안기능을 수행하는 함수의 인자로 사용되는 경우, 입력값에 대한 검증작업을 수행한 뒤 제한적으로 사용
- 중요상태정보나 인증, 권한 결정에 사용되는 정보는 쿠키로 전송되지 말아야하며 불가피하게 전송해야 하는 경우에는 암호화해서 전송

# JWT 토큰 무력화
- POST 요청을 통해 동작이 실행되지 않더라도 요청을 가로채서 쿠키에 올려져 있는 access 토큰을 가져와 decode 하여 사용자 정보를 획득할 수 있다.

# 파일 업로드/다운로드
- 업로드된 파일은 실행권한을 제거
- 파일 다운로드를 위해 요청되는 파일명에 경로를 조작하는 문자가 포함되어있는지 점검
  - "."을 기준으로 실제 확장자 여부를 확인, 대소문자를 구별
- 허가된 사용자의 허가된 안전한 파일에 대한 다운로드 요청인지 확인
- 사용자의 요청에 의해 서버에 존재하는 파일이 참조되는 경우 화이트리스트 정책으로 접근 통제

# 인증 대상 및 방식
- 중요 기능이나 리소스에 대해서는 인증 후 사용 정책이 적용되어야 한다.
- 인증 우회나 권한 상승이 발생하지 않도록 해야 한다.
- 중요 기능에 대한 2단계 인증을 고려해야한다.

## FIDO

# SSRF Server Side Request Forgery
- 공격자가 서버를 속여 무단 요청을 보내도록 유도하는 수법. 원래 서버가 할 요청을 공격자가 위조하는 것

# 인증 수행 제한
- 반복된 인증 시도를 제한하고 인증 실패한 이력을 추적하도록 노력한다.
  - 로그인 기능 구현 시, 인증시도 횟수를 제한하고 초과된 인증시도에 대해 인증제한 정책을 적용
  - 실패한 인증 시도를 로깅하여 인증시도 실패가 추적될 수 있게 해야 된다.

# 비밀번호 관리
- 취약한(간단한) 비밀번호는 금지
- 비밀번호 복구 메커니즘이 취약한 경우 공격자가 손쉽게 다른 사용자의 비밀번호를 획득, 변경할 수 있게.
- 하드코드된 비밀번호: 프로그램 내부에 비밀번호를 하드 코딩하여 내부 인증에 사용하거나 외부 컴포넌트와 통신을 하는 경우, 관리자용 계정 정보가 노출될 수 있어 위험하다. 또한 코드 내부에 하드코드된 비밀번호가 인증실패를 야기하는 경우, 시스템 관리자가 그 실패의 원인을 파악하기 쉽지 않다.


## 암호 알고리즘 종류
- 공개키(비대칭키): 암호화 키는 모든 사람이 접근할 수 있는 공개키로, 복호화는 사용자만 가지고 있는 개인키로 구성
- 대칭키
- 해쉬
  - 정보 보호 측면에서 취약하거나 위험한 암호화 알고리즘을 사용해선 안 된다.

## 암호화 시 주의사항
- 충분히 길지 않은 키를 사용하면 짧은 시간에 해독당할 가능성이 있다. 2048비트 이상이 권장이다.
- 예측 가능한 난수를 사용하는 것은 시스템의 보안 약점을 유발한다.
- 솔트: 해시 함수를 돌리기 전에 원문에 임의의 문자열을 덧붙이는 것. 매 해시 함수를 사용할 때마다 붙여줄 수 있다.
  

# 예외처리
- 명시적인 예외의 경우 예외 처리 블럭을 이용하여 발생 시 수행해야하는 기능을 구현
- 런타임 예외의 경우 입력 값의 범위를 체크, 정상적인 동작할 수 있는 값만 사용되도록 보장해야 한다.
- 너무 상세한 에러 정보가 사용자에게 노출되지 않게 한다.

# 설정 취약점
- 디렉토리 노출: 컨텐츠의 모든 구조가 노출
- 불필요한 HTTP METHOD 사용: 허용되면 안 되는 method가 허용되어 작동
- Response를 통해 웹 서버 버전 및 어플리케이션 정보가 노출. 이 경우 해당 버전의 취약점을 통해 공격 가능

# 취약한 컴포넌트 취약점
- 3rd parth 라이브러리 사용시 취약점이 발생한다.
  - Docker image: 컨테이너 실행에 필요한 다양한 패키지 등이 포함된 이미지는 취약한 버전의 패키지 사용
    - 어플리케이션 계층: 개발된 소프트웨어의 취약점
    - 런타임 및 운영체제 계층: 컨테이너의 base image 및 image 취약점
    - 컨테이너 자체 취약점
  - 3rd party component: 어플리케이션 개발에 사용되는 다양한 취약한 라이브러리 사용

# 오픈 소스 관리 프로세스
- 오픈 소스 식별: 사용 현황 및 라이선스 확인
- 소스코드 검사
- 취약점 해결
- 검토: 오픈소스 재저검을 통한 모든 이슈의 해결 여부 확인
- 승인: 오픈소스 컴플라이언스 절차 적절수행여부를 확인, 승인 혹은 거절
- 등록: 오픈소스 사용목록 추적을 위한 BOM 확정
- 고지: 오픈소스 고지문 작성(저작권, 이름 등)
- 배포전 확인: 컴플라이언스 활동을 임증할 자료 제출
- 배포
- 최종 확인