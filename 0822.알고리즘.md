# 스택을 이용한 계산기

## 1) 후위표기법의 장점
 - 괄호를 사용하지 않고도 계산 순서를 알 수 있다.
 - 연산자의 우선순위를 고려할 필요가 없다.
 - 수식을 읽으면서 바로 계산할 수 있다.

## 2) 중위 표기법에서 후위 표기법으로의 변환 알고리즘
 - 괄호를 포함한 연산자를 넣은 스택을 하나 만든다.
 - 수식을 저장할 리스트를 만든다.
 - 중위 표기법으로 쓰인 수식을 돌면서, 피연산자가 나오면 스택에 넣는다.
   - 피연산자간에 우선순위를 정해 계산 순서를 정한다. 괄호는 어떤 계산 순서보다 먼저 실행되며, 여는 괄호가 나오면 일단 집어넣고 닫는 괄호가 나오면 여는 괄호가 나올 때까지 pop을 하면서, 그 pop한 놈들을 리스트에 집어넣는다.
 - 숫자가 나오면 일단 리스트에 집어넣는다.

## 3) 스택을 이용한 후위 표기법 계산
 - 피연산자는 만나면 push
 - 연산자가 오면 그 앞에 피연산자 두 개를 pop해서 저장하는데, 위에 있는 놈을 뒤에 놓고 계산한다.
 - 그 결과를 다시 push하고, 계속한다.



# 백트래킹
- 해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아가는 기법
- 최적화 문제와 결정 문제를 해결할 수 있다. ex) 미로, n-Queen, Map coloring 부분집합의 합 등등
- 백트래킹의 경우, 모든 경우를 탐색하는 깊이우선탐색과 달리 이 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄인다.(가지치기)

## 1) 백트래킹을 이용한 알고리즘
 - 상태 공간 트리의 깊이 우선 검색을 실시한다.
 - 각 노드가 유망한지를 점검한다.
 - 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 재개한다.

## 2) 미로 찾기
 - 길을 가면서 계속 push 하다가
 - 더 이상 갈 수 있는 길이 없으면 다른 길이 있는 직전 지점까지 pop해서
 - 다시 다른 방향으로 push를 하면서 나아간다.

## 3) n-Queen 문제
 - 일정한 크기의 체스판에 퀸을 어디에, 몇 개 둘 수 있는가에 대한 문제
 - 상하좌우 대각선엔 다른 퀸을 둘 수 없다.
 - 현재 자리에 놓을 수 있으면 놓고 탐색을 재개, 아니면 자식 노드들에 대해서 체크를 하러 간다.

## 4) 부분집합 생성하기

 - 어떤 집합의 공집하과 자기자신을 포함하는 모든 부분집합을 powerset이라고 한다.

```
bit=[0,0,0,0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1]=j
        for k in rangea(2):
            bit[2]=k
            for m in range(2):
                bitp[3]=1
                print(bit)
```

 - 1~10까지의 자연수로 이루어진 부분집합에서 합이 10인 부분집합을 구할 때
```
def f(i,N):
    global answer
    if i==N:
        s=0
        for i in range(N):
            if bit[i]==1:
                s+=A[i]
                # print(A[i], end='')
        if s==10:
            answer+=1

    else:
        bit[i]=1
        f(i+1,N)
        bit[i]=0
        f(i+1,N)

A=[1,2,3,4,5,6,7,8,9,10]
bit=[0]*10
answer=0
f(0,3)
```
와 같이 모든 부분집합 중 합이 10인 놈들을 구할 수도 있다. 그렇지만 부분 집합을 만들면서 합도 같이 만들어서 10이 넘어가면 작업을 중단하도록 하면 다 만들 필요가 없어진다.

```
def f(i,N,s,t):
    global answer
    global cnt
    
    if: i==N:      # 모든 원소가 고려된 경우
        if s ==t :       # 부분집합의 합이 t면
            answer +=1
        return

    elif s>t:       # 지금까지 더한 게 목표값보다 커버리면
        return
        
    else:
        f(i+1, N, s+A[i], t)    # A[i]가 포함된 경우
        f(i+1, N, s, t)         # A[i]가 포함되지 않은 경우 경우



A=[1,2,3,4,5,6,7,8,9,10]
bit=[0]*10
answer=0
f(0,3)
```


```
def f(i,N):
    if i==N:
        print(n)
    else:
        for j in range(1,N):
            P[i],P[j] = P[j], P[i]
            f(1+i,N)
            P[i],P[j] = P[j], P[i]

P = [1,2,3]
F(0,3)
```