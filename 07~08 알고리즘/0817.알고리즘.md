# 1. 스택
- 물건을 쌓아올리듯 자료를 쌓아올린 형태의 자료구조
- 자료 간의 관계가 1:1인 선형 구조
- 자료를 삽입하거나 꺼낼 수 있다.
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(Last-In-First-Out)이라고 부른다.


## 1) 스택을 프로그램에서 구현하기 위한 자료구조와 연산

### (1) 자료를 선형으로 저장할 저장소
- 배열을 사용할 수 있다.
- 저장소 자체를 스택이라 부르기도 한다.
- 스택에서 마지막 삽입된 원소의 위치를 top 혹은 stack pointer라고 부른다.
```
Class Stack:
    def __init__.self(self, size):
        self.size=size
        self.data=[none]*size
        self.top=-1

    def push(self, value):
        if self.is_full():
            print('~~')
        else:
            self.top +=1
            self.data[self.top]=value
    

```
  
### (2) 연산
- 삽입 : 저장소에 자료를 저장한다. push라고 부른다.
```
def push(item, size):
    global top
    top+=1
    if top==size:
        print('overflow!')      # top이 범위를 벗어난다. 그냥 디버깅용
    else:
        stack[top]=size

size=10
stack = [0]*size                # 보통 사이즈를 정해놓고 쓴다.
top=-1

push(10,size)
```
```
top+=1
stack[top] = 20
```
append를 사용할 수도 있지만 리스트의 크기가 커지면 느리다.


- 삭제 : 저장소에서 자료를 꺼내고 top을 한 칸 내린다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부른다.
```
def pop():
    global top
    if top == -1:               # 비어있는 데 꺼내려고 할 때
        return 0
    else:
        top -=1
        return stack[top+1]

print(pop())
```
```
if top>-1:
    top -=1
    print(stack[pop])
```


- 스택이 공백인지 아닌지 확인하는 연산. isEmpty
- 스택의 top에 있는 원소를 반환하는 연산. peek


### (3) 스택 구현 연습
```
stackSize=10
stack = [0]*stacksize
top= -1

top +=1         #push(1)
stack[top] = 1

top +=1         #push(2)
stack[top] = 2

top-=1                  # 먼저 하나 줄이고
temp = stack[top+1]     # 빼오든가
print(temp)

temp = stack[top]       # 빼오고
top -=1                 # 하나 줄이던가
print(temp)
```

### (4) 스택 구현 고려 사항
- 1차원 배열을 사용하여 구현할 경우 크기를 변경하기 어렵다.
- 이를 해결학 위해 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법으로, 구현이 복잡하지만 메모리를 효율적으로 사용할 수 있다.


## 2) 스택의 응용

### (1) 괄호검사
- 왼쪽 괄호의 개수와 종류가 오른쪽 괄호의 개수와 종류가 같아야 한다.
`if (    (i==0)   && (j==0)`
- 여는 괄호가 나오면 push를 하고 닫는 괄호가 나오면 pop을 해서 검사가 끝나면 스택이 깔끔하게 비어있어야한다. 만약 여는 괄호가 많다면 스택에 무언가 남아있을 것이고, 닫는 괄호가 많다면 오류가 난다.

### (2) function call
- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로 이를 이용해 관리한다.
  - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입.
  - 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 pop하면서 프레임에 저장되어 있던 복귀 주소를 확인하고 확인
  - 함수 호출과 복귀에 따라 이 돠정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.
```
|__|    
|__|    # 여기서 함수 호출
|  |            |
|__|            ▽
|__|    # 이 스택 메모리에 함수가 할당되고 top이 여기로 옴
|  |    # 여기서 함수 실행이 끝나면 다시 비워버림
```


# 2. 재귀호출
- 자기 자신을 호출하여 순환 수행 하는 것. 사실 호출이라기 보다는 옮겨가는 것이지만
- 루프가 아니라 다른 함수를 호출하여 서로 다른 메모리에 저장되어 작동한다.
- 파이썬엔 최대 재귀 호출 회수의 기본값이 정해져있어서 따로 설정해주지 않으면 오류가 날 수 있다.
```
def f(i(단계),N(목표치)):
    if i==N:            # 목표에 도달
        return ~~
    else:
        ~~(현재 단계에서 할 일)
        f(i+1,N) # 다음 단계로
```

```
|___|    
|_0_| i
|_3_| N          
|   |        ↓   ↑               
|___|            
|_1_|    
|_3_|
|   |        ↓   ↑
|___|            
|_2_|    
|_3_|
|   |        ↓   ↑
|___|
|_3_|    
|_3_|
|   |
```

## (1) 재귀함수 연습
```
def f(i,N):
    if i==N:
        return '접근 완료'
    
    else:
        print(A[i])
        return f(i+1,N)     # 다음 원소로 이동


N=3
A=[1,2,3]
```

# 3. Memoization
- 재귀 호출의 경우 엄청난 중복 호출이 존재할 수 있다.
- 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술로, 동적 계획법의 핵심이 되는 기술이다.
  
- 예를 들어 피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면 실행시간을 줄일 수 있다.
```
#memo을 위한 배열을 할당하고, 모두 0으로 초기화한다.
#memo[0]을 0으로 memo[1]는 1로 초기화한다.

def fibo1(n):
    if n>=2 and len(memo) <=N:
        memo.append(fibo(n-1)+fibo(n-2))    # append 하지 말고 스택을 만들어 집어넣는 게 빠르긴 하다.
    return memo[n]

memo=[0,1]
```

# 4. Dynamic Programming(동적 계획)
- 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여 최종적으로 원래 주어진 입력 의 문제를 해결하는 알고리즘
    - 문제를 부분 문제로 나눈다.
    - 부분 문제를 나누는 일을 끝냈으면 가장 작은 부분 문제부터 헤를 구한다.
    - 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.

```
def fibo_dp(n):
    table[0]=0
    table[0]=1
    for i in range(2, n+1):
        table[i]=table[i-1]+table[i-2]
    return

table=[0]*101
fibo_dp(100)
print(table[20])    
```


# 5. DFS 깊이우선탐색
- 비선형구조인 그래프구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함
- 깊이 우선 탐색(Depth First Search), 너비(Breadth First Search) 우선 탐색. 두 방법이 있다.

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림기의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

## 1) DFS 알고리즘
- 1) 시작 정점 v를 결정하여 방문한다.

- 2) 정점 v에 인접한 정점 중에서
  - 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로하여 다시 2)를 반복한다.
  - 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 다시 v로 하여 다시 2)를 반복한다.

- 3) 스택이 공백이 될 때까지 2)를 반복한다.
```
adjList=[[1,2],
         [0,3,4],
         [0,4],
         [1,5],
         [1,2,5],
         [3,4,6],
         [5]]          # 인접 여부를 2차원 배열로 표시


def DFS(v,N):
    top=-1
    visited[v]=1

    while 1:
        for w in adjList[v]:
            if visited[w]==0 :      # v에 인접한 w 중에 방문하지 않은 w가 있으면
                top +=1             # push
                stack[top] = v      

                v = w               # w에 방문
                visited[w] = 1
                break

            else:                   # w가 없으면
                if top != -1:       # 스택이 비어있지 않으면
                    v = stack[top]
                    top -=1
                else:
                    break

N=7
visited=[0]*N
stack=[0]*N
dfs(1,N)
```


```
V,E = map(int,input().split())
N = V + 1
adjList = [[] for _ in range(N)]

for _ in range(E):                      # 두 개씩 여러 줄 들어오는 데이터를 토대로
    a, b=map(int,input().split())
    adjList[a].append(b)                # adjList를 만든다.
    adjList[b].append(a)                # 서로 연결되어있다.
```


```
def dfs(v):
    print(v)                 # v 방문
    visited[v]=1
    for w in adjList[v]: 
        if vistied[w]==0:    # 방문한 적 없는 w
            dfs(w)

```