# 알고리즘 01

## 1. 알고리즘
  - 문제를 해결하기 위한 절차나 방법
  - 한 문제에 대해서도 여러 개의 알고리즘이 존재할 수 있기 때문에, 어떤 알고리즘이 이 문제 혹은 우리의 목표에 적합하고 좋은 알고리즘인지 파악할 수 있어야한다.

### 1) 좋은 알고리즘이란?
  - 정확성
  
  - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
        ```
        def calsum(n):
            return n*(n+1)/2  #3번 
        ```

  - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가

  - 단순성

  - 최적성


### 2) 시간 복잡도
 - 실제 걸리는 시간
 - 실행되는 명령문의 개수를 계산
 - Big-Oh notation
   - 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시. 계수는 생략
   - n에 대한 2차 함수로 나온다면, O(n**2) 



## 2. 배열(Array)란
 - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

### 1) 배열의 필요성
 - 여러 개의 변수가 필요할 때, 일일히 다른 변수명을 이용하여 자료에 접근하는 것이 매우 비효율적인 경우가 있을 수 있다.
 - 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수를 사용할 수 있다.
 - for 등을 통해 한 번에 여러 변수에 접근할 수 있다.
 
### 2) 1차원 배열

#### (1) 1차원 배열의 선언
 ```
 Arr=list()
 Arr=[]
 Arr[0]*10
 ```
 
#### (2) 1차원 배열의 접근
Arr[\idx]=10 #배열 Arr의 idx에 10을 저장하라

#### (3) 배열을 활용한 예제
 - 상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 수하여 그 낙차를 리턴하는 프로그램을 작성하시오.
 - 중력은 회전이 완료된 후 적용된다.
 - 상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 벽에서 떨어져서 쌓인 상자는 없다.
 - 방의 길이는 항상 가로 100, 세로 100이다.


### 3) 정렬
 - 2 개 이상의 자료를 특정 기준(key)에 의해 작은 값부터 큰 값, 혹은 그 반대로 재배열하는 것

#### (1) 대표적인 정렬의 종류

##### I 버블 정렬
 - 인접한 두 개의 원소를 비교하여 자리를 계속 교환하는 방식
 - 처음 정렬을 실행하면 맨 마지막에 제일 큰 놈이 오니까 걔는 더 이상 움직일 필요가 없다. 그럼 남은 구간에서 같은 작업을 실행하면 되고, 이걸 원소가 2개 남을 때까지 반복하면 된다.
```
BubbleSort(배열, 배열의 크기 N):
    for i -> N-1 ~ 1:
        for j -> 0 ~ i-1:
            if arr[j]>arr[j+1]:
                arr[j+1]랑 arr[j]랑 바꾼다.
```

```
def BubbleSort():
    for i in range(n-1,0,-1):
        for j in range(0,1):
            if a[j]>a[j+1]:
                a[j],a[j+1]=a[j+1],a[j]
```

##### II 카운팅 정렬
 - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
 - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능.
 - 시간 복잡도 = O(n(배열의 크기)+k(집합 내 가장 큰 정수))

 - 카운팅 정렬의 과정
   - Data에서 각 항목들의 발생 회수를 세고, 해당 정수 항목들을 직접 인덱스로 하는 카운트 배열 counts에 저장한다. 
   - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를, 각 항목을 포함해 그때까지 몇 개의 원소가 있는지를 세서 그 수를 다시 원소로 조정한다.
   - 원본 데이터와 길이가 같은 Temp 배열을 만든다. 맨 뒤 원소를 보자. 해당 원소의 인덱스에 해당하는 counts 배열의 원소의 수를 1 감소시키고 TEMP 배열에 그 감소된 수에 해당하는 인덱스에 그 수를 집어넣는다. 

```
A:입력된 배열
B:정렬된 배열

def CountingSort(A,B,k):
    C=[0]*(k+1)

    for i in range(0, len(A)):
        C[A[i]]+=1
    
    for i in rnage(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(B)-1,-1,-1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]

```


 - 이 경우, 원본 데이터에서 값이 같은 놈들 끼리의 순서도 보존된다는 장점이 있다.


##### III 선택 정렬

##### IX 퀵 정렬

##### X 삽입 정렬

##### XI 병합 정렬


### 4) 완전 검색
 - 모든 경우의 수를 테스트 하고 최종 해법을 도출한다. 경우의 수가 작을 때 유용하고 알고리즘의 효율을 위해 비교되기도 한다.
 - 순열
   - 순서가 있는 서로 다른 원소들의 집합
    ```
    for i1 in range(1,4):
        for i2 in range(1,4):
            if i2 != i1:
                for i3 in range(1,4):
                    if i3 != i1 and i3 != i2 :
                        print(i1,i2,i3)
    ```

### 5) 탐욕 알고리즘
 - 최적해를 구하는 데 사용되는 근시안적인 방법
   - 해 선택:현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다.
   - 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지 검사한다.
   - 해 검사 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 해 선택으로 돌아간다.

ex) baby-gin 문제
    n n n:triplet
    n n+1 n+2 : run
    임의의 6자리 숫자로 숫자를 중복으로 사용하지 않고 triplet과 run을 합쳐 2개가 만들어진다면, baby-gin
    ```
    num=~~
    c=[0]*12            # Index range 방지를 위해 실제 길이보다 2를 길게 해줬다.

    for i in range(6):
        c[num%10] += 1  #일의 자리를 떼어내서 그 수에 해당하는 인덱스에 1 추가
        num //= 10      #몫을 다시 num으로 반환해서 반복

    i=0
    tri=run=0

    while i<10 :
        if c[i] >=3:     #triplet 조사
            c[i] -= 3
            tri +=1
            continue;
        
        if c[i]>= and c[i+1]>=1 and c[i+1]>=1:    # run 조사하고 데이터 삭제
            c[i] -=1
            c[i+1] -=1
            c[i+2] -=1
            run+=1
            contunue
        i+=1

    if run+tri == 2 : print('Baby Gin')
    else : print("Lose")
    ```