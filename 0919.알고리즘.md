# Start

## 프로그래밍을 하기 위한 제약 조건과 요구사항
- 프로그래밍 언어의 특성
- 프로그램이 동작할 HW와 OS에 관한 지식
- 라이브러리들의 유의사항들
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드

## 문제 해결 과정
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 개선할 방법이 있는지 찾아본다.

## 알고리즘의 효율
- 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
- 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
- 시간적 복잡도 분석은 환경적 차이로 인해 분석이 어렵다.
  - 하드웨어 환경에 따라 처리 시간이 달라진다.
    - 부동소수 처리 프로세서 존재 유무, 나눗셈 가속기능 유무 등
    - 입출력 장비의 성능, 공유여부
  - 소프트웨어 환경에 따라 처리시간이 달라진다.
    - 언어 종류
    - 운영체제, 컴파일러 종류

### 복잡도의 점근적 표기
- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
- 이를 단순하 함수로 표현하기 의해 점근적 표기(Asympototic Notation)을 사용한다.
  - 빅오
  - 빅오메가
  - 빅세타

#### 1) 빅오
- 복잡도의 점근적 상한. 최악의 경우에 이 정도다.
- 복잡도가 $f(n)=2n^2-7n+4$ 라면 복잡도는 $O(n)=n^2$

#### 2) 빅오메가
- 복잡도의 전금적 하한
- 복잡도가 $f(n)=2n^2-7n+4$ 라면 복잡도는 $Ω(n)=n^2$
  
# 표준 입출력

## Python3 표준 입출력
- 입력
  - Raw 값의 입력 : `input()` 받은 값을 문자열로 취급
  - Evaluated된 값 입력: `eval(input())` 받은 입력값을 평가된 데이터형으로 취급
- 출력
  - print()
  - print(,end='') 마지막 개행 문자 제외
  - print('%d' % number) Formatting 된 출력

- 파일의 내용을 받아오는 법
```
import sys
sys.stdin=open('a.txt','r')
```
파일의 크기가 1mb 이상일 때 특히 유용하다.

# 비트 연산

## 비트 연산자
- & AND
- | OR
- ^ XOR
- ~ 피연산자의 모든 비트를 반전시킨다.
- <\<n 왼쪽으로 n만큼 이동
- \>>n 오른쪽으로 n만큼 이동

## 예시
### 1<<n
- $2^n$의 값을 갖는다.
- 원소가 n개일 경우위 모든 부분집합의 수

### i&*(1<<j)
- i의 j번째 비트가 1인지 아닌지를 의미한다.

```
def bit_print(i):
    s=''
    for j in range(7, -1, -1):
        s+= '1' if (i&(1<<j)) else '0'
    print(s)
```



## 엔디안(Endianness)
- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법. HW 아키텍처마다 다르다.
  - 빅 엔디안: 큰 단위가 앞에 나옴. 네트워크에서 사용 0x1234의 경우 12 34와 같이 표현
  - 리틀 엔디안: 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터에서 사용 0x1234의 경우 34 12와 같이 표현
```
import sys
print(sys.byteorder)
```
### 엔디안 변경
```
def ce1(n):
  return (n << 24 & 0xff000000) | (n << 8 & 0xff0000) | (n >> 8 & 0xff00) | (n >> 24 & 0xff)
```
- `(n << 24 & 0xff000000)` 04를 맨 앞으로
- `(n << 8 & 0xff0000)` 03을 앞에서 두번째
- `(n >> 8 & 0xff00)` 02를 앞에서 세번째
- `(n >> 24 & 0xff)` 01을 맨 뒤로


# 진수
- 2진수 8잔수 16 진수 등등...
- 10진수 -> 타진수로 변환: 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
- 소수점이 있으면, -제곱으로 계산한다.


## 컴퓨터에서 음의 정수 표현법
- 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환
  -6: 1(부호) 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 : 부호와 절대값표현
  -6: 1(부호) 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 : 1의 보수를 표현

- 2의 보수: 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.


# 실수
- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다. 
- 부동 소수점표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.

$1001.0011 → 1.0010011×2^3$

## 실수를 저장하기 위한 형식
- 단정도 실수(32비트): 부호1비트 지수8비트 가수23비트
- 배정도 실수(64비트): 부호1비트 지수11비트 가수52비트
- 예: 1001.0011
  - 정수부 첫 번째 자리가 1이 되도록 오른쪽으로 시프트
 
  `0001.0010011`

  - 소수점 이하를 23비트로 만든다.
  `0001.00100110000000000000000`

  - 소수점 이하만을 가수 부분에 저장: 00100110000000000000000
  - 지수 부분은 시프트한 자릿수 만큼 증가 또는 감소
  `1.0001.0010011*2^3`

- 컴퓨터는 실수를 근사적으로 표현한다.