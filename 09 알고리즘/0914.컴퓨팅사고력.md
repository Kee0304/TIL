# 컴퓨팅 사고력 서론

## 논리와 증명
- 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함

### 1) 이산수학에서 기본적으로 쓰이는 기호
- ∧: and
- ∨: or
- ∀x: 모든 x에 대하여
- ∃y: 어떤 y에 대하여
- 예시) ∀x∃yP(x,y): 모든 x에 대하여  P(x,y)가 (참 혹은 거짓)이 되는 y가 있다.


### 2) 귀납법
- 초기 설정에 대하여 만족하고, 임의의 정수 n에 대하여 P(n)가 참이라고 가정했을 때 P(n+1)도 참임을 보여서 참임을 증명하는 과정

### 3) 귀류법
- 증명하고자 하는 명제를 거짓이라 가정하고 하나하나 풀어나아가서 말이 안 됨을 밝힘으로써 명제가 참임을 증명하는 과정

## 수와 표현
- 컴퓨터는 0과 1로 표현할 수 있는 비트들을 모아 수를 표현. 보통 k비트라 하면 경우 0부터 2<sup>k</sup>-1 까지 표현 가능
- 범위 자체는 달라질 수 있지만 최대 2<sup>k</sup>가지의 값을 표현하는 것이 가능하다.(예를 들어 범위를 -7부터 8까지로 해도 16개의 숫자임에는 변함이 없다.)

### 1) 어떤 값을 표현하기 위해선 몇 개의 비트가 필요할까?
- 2<sup>k</sup>-1>=n이 성립해야함.
- 이는 k>=log(n+1)이므로 약 logn비트 필요 (컴퓨팅에서 log는 기본적으로 2를 밑으로 한다.)


# 기초 수식
- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다.
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘 계산이 얼마나 들 지 예상할 수 있다.

## 예시
### 1)
T(n)=T(n-1)+logn, T(0)=1
↓
T(n)-T(0)=log(n!)
인데
log(n!)<=log(n**n)
이므로
O(nlogn)이라 할 수 있다.

### 2)
T(n)=T(n/2)+1
    =T(n/4)+1+1
    ...
    =T(n/2<sup>k</sup>)+k
    =T(1)+k                    n/2<sup>k</sup>=1, n=2<sup>k</sup>
    =1+logn


### 3)
T(n)=T(n/2)+n,T(1)=1
이면
T(n/2)=T(n/4)+(2/n)
이므로
T(n)=T(n/(2<sup>k</sup>))+(n/2<sup>k-1</sup>)+...+n/2+n
    =T(1)+n((1/2)<sup>k</sup>+...+(1/2)<sup>2</sup>+1/2)
으로 등비수열의 합과 같이 나온다.

# 재귀
- 자기 자신응 호출하는 함수.
## 예시
### 1) 피보나치 수열
```
def fibo(n):
    if n<=2:
        return 1
    else:
        return fibo(n-1)+fibo(n-2)
```
T(n)=T(n-1)+T(n-2)+1<=T(n-1)+T(n-1)+1
T(n)<=2T(n-1)+1
T(n)<=2(2T(n-2)+1)+1=2(2(2T(n-3)+1)+1)+1
...
T(n)<=2<sup>k</sup>T(n-k)+2<sup>k-1</sup>+...+2+1
    <=2<sup>n</sup>+2<sup>n</sup>-2
이 되므로 시간 복잡도는 O(2<sup>n</sup>)

# 동적 프로그래밍
- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것이다.
- 결과 값을 순서를 정해서 계산할 수도 있어서 유용하다.